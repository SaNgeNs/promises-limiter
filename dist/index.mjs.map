{"version":3,"sources":["../index.ts"],"sourcesContent":["type AsyncFunction<T = any> = (signal: AbortSignal) => Promise<T>;\n\ninterface LimitConfig {\n  maxConcurrent: number;\n  delayBetweenBatches: number;\n  progressiveDelayStep: number;\n  maxProgressiveDelay: number;\n  onSuccess?: (result: any) => void;\n  onError?: (error: any) => void;\n  onProgress?: (progress: { completed: number; remaining: number; failed: number }) => void;\n  onComplete?: (results: { success: any[]; failed: any[] }) => void;\n}\n\nclass Limiter {\n  private requests: AsyncFunction[];\n\n  private config: LimitConfig;\n\n  private successCount: number = 0;\n\n  private failCount: number = 0;\n\n  private isCancelled: boolean = false;\n\n  private abortControllers: AbortController[] = [];\n\n  private async executeRequest(req: AsyncFunction): Promise<any> {\n    const controller = new AbortController();\n    this.abortControllers.push(controller);\n    const { signal } = controller;\n\n    try {\n      return await req(signal);\n    } catch (error) {\n      this.failCount++;\n\n      if (this.config.onError) this.config.onError(error);\n\n      return error;\n    } finally {\n      this.abortControllers = this.abortControllers.filter((ctrl) => ctrl !== controller);\n    }\n  }\n\n  constructor(requests: AsyncFunction[]) {\n    this.requests = requests;\n    this.config = {\n      maxConcurrent: 10,\n      delayBetweenBatches: 0,\n      progressiveDelayStep: 0,\n      maxProgressiveDelay: 0,\n    };\n  }\n\n  max(concurrent: number) {\n    this.config.maxConcurrent = concurrent;\n    return this;\n  }\n\n  delay(milliseconds: number) {\n    this.config.delayBetweenBatches = milliseconds;\n    return this;\n  }\n\n  progressiveDelay(step: number, maxDelay: number) {\n    this.config.progressiveDelayStep = step;\n    this.config.maxProgressiveDelay = maxDelay;\n    return this;\n  }\n\n  success(callback: (result: any) => void) {\n    this.config.onSuccess = callback;\n    return this;\n  }\n\n  error(callback: (error: any) => void) {\n    this.config.onError = callback;\n    return this;\n  }\n\n  progress(callback: (progress: { completed: number; remaining: number; failed: number }) => void) {\n    this.config.onProgress = callback;\n    return this;\n  }\n\n  complete(callback: (results: { success: any[]; failed: any[] }) => void) {\n    this.config.onComplete = callback;\n    return this;\n  }\n\n  cancel() {\n    this.isCancelled = true;\n    this.abortControllers.forEach((controller) => controller.abort());\n  }\n\n  async run(): Promise<{ success: any[]; failed: any[] }> {\n    const successResults: any[] = [];\n    const failedResults: any[] = [];\n    let delay = this.config.delayBetweenBatches;\n    let currentBatchIndex = 0;\n\n    const totalRequests = this.requests.length;\n\n    while (currentBatchIndex < totalRequests) {\n      if (this.isCancelled) {\n        break;\n      }\n\n      const batch = this.requests.slice(\n        currentBatchIndex,\n        currentBatchIndex + this.config.maxConcurrent,\n      );\n      currentBatchIndex += this.config.maxConcurrent;\n\n      await Promise.all(\n        batch.map(async (req) => {\n          const result = await this.executeRequest(req);\n\n          if (result && !(result instanceof Error)) {\n            this.successCount++;\n\n            if (this.config.onSuccess) this.config.onSuccess(result);\n\n            successResults.push(result);\n          } else {\n            failedResults.push(result);\n          }\n        }),\n      );\n\n      if (this.config.onProgress) {\n        this.config.onProgress({\n          completed: this.successCount,\n          remaining: totalRequests - currentBatchIndex,\n          failed: this.failCount,\n        });\n      }\n\n      if (currentBatchIndex < totalRequests) {\n        await new Promise((resolve) => { setTimeout(resolve, delay); });\n        delay = Math.min(delay + this.config.progressiveDelayStep, this.config.maxProgressiveDelay);\n      }\n    }\n\n    if (this.config.onComplete && !this.isCancelled) {\n      this.config.onComplete({ success: successResults, failed: failedResults });\n    }\n\n    return { success: successResults, failed: failedResults };\n  }\n}\n\nexport function PromisesLimiter(requests: AsyncFunction[]) {\n  return new Limiter(requests);\n}\n"],"mappings":"AAaA,IAAMA,EAAN,KAAc,CACJ,SAEA,OAEA,aAAuB,EAEvB,UAAoB,EAEpB,YAAuB,GAEvB,iBAAsC,CAAC,EAE/C,MAAc,eAAeC,EAAkC,CAC7D,IAAMC,EAAa,IAAI,gBACvB,KAAK,iBAAiB,KAAKA,CAAU,EACrC,GAAM,CAAE,OAAAC,CAAO,EAAID,EAEnB,GAAI,CACF,OAAO,MAAMD,EAAIE,CAAM,CACzB,OAASC,EAAO,CACd,YAAK,YAED,KAAK,OAAO,SAAS,KAAK,OAAO,QAAQA,CAAK,EAE3CA,CACT,QAAE,CACA,KAAK,iBAAmB,KAAK,iBAAiB,OAAQC,GAASA,IAASH,CAAU,CACpF,CACF,CAEA,YAAYI,EAA2B,CACrC,KAAK,SAAWA,EAChB,KAAK,OAAS,CACZ,cAAe,GACf,oBAAqB,EACrB,qBAAsB,EACtB,oBAAqB,CACvB,CACF,CAEA,IAAIC,EAAoB,CACtB,YAAK,OAAO,cAAgBA,EACrB,IACT,CAEA,MAAMC,EAAsB,CAC1B,YAAK,OAAO,oBAAsBA,EAC3B,IACT,CAEA,iBAAiBC,EAAcC,EAAkB,CAC/C,YAAK,OAAO,qBAAuBD,EACnC,KAAK,OAAO,oBAAsBC,EAC3B,IACT,CAEA,QAAQC,EAAiC,CACvC,YAAK,OAAO,UAAYA,EACjB,IACT,CAEA,MAAMA,EAAgC,CACpC,YAAK,OAAO,QAAUA,EACf,IACT,CAEA,SAASA,EAAwF,CAC/F,YAAK,OAAO,WAAaA,EAClB,IACT,CAEA,SAASA,EAAgE,CACvE,YAAK,OAAO,WAAaA,EAClB,IACT,CAEA,QAAS,CACP,KAAK,YAAc,GACnB,KAAK,iBAAiB,QAAST,GAAeA,EAAW,MAAM,CAAC,CAClE,CAEA,MAAM,KAAkD,CACtD,IAAMU,EAAwB,CAAC,EACzBC,EAAuB,CAAC,EAC1BC,EAAQ,KAAK,OAAO,oBACpBC,EAAoB,EAElBC,EAAgB,KAAK,SAAS,OAEpC,KAAOD,EAAoBC,GACrB,MAAK,aAD+B,CAKxC,IAAMC,EAAQ,KAAK,SAAS,MAC1BF,EACAA,EAAoB,KAAK,OAAO,aAClC,EACAA,GAAqB,KAAK,OAAO,cAEjC,MAAM,QAAQ,IACZE,EAAM,IAAI,MAAOhB,GAAQ,CACvB,IAAMiB,EAAS,MAAM,KAAK,eAAejB,CAAG,EAExCiB,GAAU,EAAEA,aAAkB,QAChC,KAAK,eAED,KAAK,OAAO,WAAW,KAAK,OAAO,UAAUA,CAAM,EAEvDN,EAAe,KAAKM,CAAM,GAE1BL,EAAc,KAAKK,CAAM,CAE7B,CAAC,CACH,EAEI,KAAK,OAAO,YACd,KAAK,OAAO,WAAW,CACrB,UAAW,KAAK,aAChB,UAAWF,EAAgBD,EAC3B,OAAQ,KAAK,SACf,CAAC,EAGCA,EAAoBC,IACtB,MAAM,IAAI,QAASG,GAAY,CAAE,WAAWA,EAASL,CAAK,CAAG,CAAC,EAC9DA,EAAQ,KAAK,IAAIA,EAAQ,KAAK,OAAO,qBAAsB,KAAK,OAAO,mBAAmB,EAE9F,CAEA,OAAI,KAAK,OAAO,YAAc,CAAC,KAAK,aAClC,KAAK,OAAO,WAAW,CAAE,QAASF,EAAgB,OAAQC,CAAc,CAAC,EAGpE,CAAE,QAASD,EAAgB,OAAQC,CAAc,CAC1D,CACF,EAEO,SAASO,EAAgBd,EAA2B,CACzD,OAAO,IAAIN,EAAQM,CAAQ,CAC7B","names":["Limiter","req","controller","signal","error","ctrl","requests","concurrent","milliseconds","step","maxDelay","callback","successResults","failedResults","delay","currentBatchIndex","totalRequests","batch","result","resolve","PromisesLimiter"]}