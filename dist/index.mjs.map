{"version":3,"sources":["../index.ts"],"sourcesContent":["export type AsyncFunction<T = any> = (signal: AbortSignal) => Promise<T>;\n\ninterface LimitConfig<T, E> {\n  maxConcurrent: number;\n  delayBetweenBatches: number;\n  progressiveDelayStep: number;\n  maxProgressiveDelay: number;\n  onSuccess?: (result: T) => void;\n  onError?: (error: E) => void;\n  onProgress?: (progress: { completed: number; remaining: number; failed: number }) => void;\n  onComplete?: (results: { success: T[]; failed: E[] }) => void;\n}\n\nclass Limiter<T = any, E = any> {\n  private requests: AsyncFunction<T>[];\n\n  private config: LimitConfig<T, E>;\n\n  private successCount: number = 0;\n\n  private failCount: number = 0;\n\n  private isCancelled: boolean = false;\n\n  private abortControllers: AbortController[] = [];\n\n  private async executeRequest(req: AsyncFunction<T>): Promise<T | E> {\n    const controller = new AbortController();\n    this.abortControllers.push(controller);\n    const { signal } = controller;\n\n    try {\n      return await req(signal);\n    } catch (error) {\n      this.failCount++;\n\n      if (this.config.onError) this.config.onError(error as E);\n\n      return error as E;\n    } finally {\n      this.abortControllers = this.abortControllers.filter((ctrl) => ctrl !== controller);\n    }\n  }\n\n  constructor(requests: AsyncFunction<T>[]) {\n    this.requests = requests;\n    this.config = {\n      maxConcurrent: 10,\n      delayBetweenBatches: 0,\n      progressiveDelayStep: 0,\n      maxProgressiveDelay: 0,\n    };\n  }\n\n  max(concurrent: number) {\n    this.config.maxConcurrent = concurrent;\n    return this;\n  }\n\n  delay(milliseconds: number) {\n    this.config.delayBetweenBatches = milliseconds;\n    return this;\n  }\n\n  progressiveDelay(step: number, maxDelay: number) {\n    this.config.progressiveDelayStep = step;\n    this.config.maxProgressiveDelay = maxDelay;\n    return this;\n  }\n\n  success(callback: (result: T) => void) {\n    this.config.onSuccess = callback;\n    return this;\n  }\n\n  error(callback: (error: E) => void) {\n    this.config.onError = callback;\n    return this;\n  }\n\n  progress(callback: (progress: { completed: number; remaining: number; failed: number }) => void) {\n    this.config.onProgress = callback;\n    return this;\n  }\n\n  complete(callback: (results: { success: T[]; failed: E[] }) => void) {\n    this.config.onComplete = callback;\n    return this;\n  }\n\n  cancel() {\n    this.isCancelled = true;\n    this.abortControllers.forEach((controller) => controller.abort());\n  }\n\n  async run(): Promise<{ success: T[]; failed: E[] }> {\n    const successResults: T[] = [];\n    const failedResults: E[] = [];\n    let delay = this.config.delayBetweenBatches;\n    let currentBatchIndex = 0;\n\n    const totalRequests = this.requests.length;\n\n    while (currentBatchIndex < totalRequests) {\n      if (this.isCancelled) {\n        break;\n      }\n\n      const batch = this.requests.slice(\n        currentBatchIndex,\n        currentBatchIndex + this.config.maxConcurrent,\n      );\n      currentBatchIndex += this.config.maxConcurrent;\n\n      await Promise.all(\n        batch.map(async (req) => {\n          const result = await this.executeRequest(req);\n\n          if (result && !(result instanceof Error)) {\n            this.successCount++;\n\n            if (this.config.onSuccess) this.config.onSuccess(result as T);\n\n            successResults.push(result as T);\n          } else {\n            failedResults.push(result as E);\n          }\n        }),\n      );\n\n      if (this.config.onProgress) {\n        this.config.onProgress({\n          completed: this.successCount,\n          remaining: Math.max(totalRequests - currentBatchIndex, 0),\n          failed: this.failCount,\n        });\n      }\n\n      if (currentBatchIndex < totalRequests) {\n        await new Promise((resolve) => { setTimeout(resolve, delay); });\n        delay = Math.min(\n          delay + this.config.progressiveDelayStep,\n          this.config.maxProgressiveDelay || delay,\n        );\n      }\n    }\n\n    if (this.config.onComplete && !this.isCancelled) {\n      this.config.onComplete({ success: successResults, failed: failedResults });\n    }\n\n    return { success: successResults, failed: failedResults };\n  }\n}\n\nexport function promisesLimiter<T = any, E = any>(requests: AsyncFunction<T>[]) {\n  return new Limiter<T, E>(requests);\n}\n"],"mappings":"AAaA,IAAMA,EAAN,KAAgC,CACtB,SAEA,OAEA,aAAuB,EAEvB,UAAoB,EAEpB,YAAuB,GAEvB,iBAAsC,CAAC,EAE/C,MAAc,eAAeC,EAAuC,CAClE,IAAMC,EAAa,IAAI,gBACvB,KAAK,iBAAiB,KAAKA,CAAU,EACrC,GAAM,CAAE,OAAAC,CAAO,EAAID,EAEnB,GAAI,CACF,OAAO,MAAMD,EAAIE,CAAM,CACzB,OAASC,EAAO,CACd,YAAK,YAED,KAAK,OAAO,SAAS,KAAK,OAAO,QAAQA,CAAU,EAEhDA,CACT,QAAE,CACA,KAAK,iBAAmB,KAAK,iBAAiB,OAAQC,GAASA,IAASH,CAAU,CACpF,CACF,CAEA,YAAYI,EAA8B,CACxC,KAAK,SAAWA,EAChB,KAAK,OAAS,CACZ,cAAe,GACf,oBAAqB,EACrB,qBAAsB,EACtB,oBAAqB,CACvB,CACF,CAEA,IAAIC,EAAoB,CACtB,YAAK,OAAO,cAAgBA,EACrB,IACT,CAEA,MAAMC,EAAsB,CAC1B,YAAK,OAAO,oBAAsBA,EAC3B,IACT,CAEA,iBAAiBC,EAAcC,EAAkB,CAC/C,YAAK,OAAO,qBAAuBD,EACnC,KAAK,OAAO,oBAAsBC,EAC3B,IACT,CAEA,QAAQC,EAA+B,CACrC,YAAK,OAAO,UAAYA,EACjB,IACT,CAEA,MAAMA,EAA8B,CAClC,YAAK,OAAO,QAAUA,EACf,IACT,CAEA,SAASA,EAAwF,CAC/F,YAAK,OAAO,WAAaA,EAClB,IACT,CAEA,SAASA,EAA4D,CACnE,YAAK,OAAO,WAAaA,EAClB,IACT,CAEA,QAAS,CACP,KAAK,YAAc,GACnB,KAAK,iBAAiB,QAAST,GAAeA,EAAW,MAAM,CAAC,CAClE,CAEA,MAAM,KAA8C,CAClD,IAAMU,EAAsB,CAAC,EACvBC,EAAqB,CAAC,EACxBC,EAAQ,KAAK,OAAO,oBACpBC,EAAoB,EAElBC,EAAgB,KAAK,SAAS,OAEpC,KAAOD,EAAoBC,GACrB,MAAK,aAD+B,CAKxC,IAAMC,EAAQ,KAAK,SAAS,MAC1BF,EACAA,EAAoB,KAAK,OAAO,aAClC,EACAA,GAAqB,KAAK,OAAO,cAEjC,MAAM,QAAQ,IACZE,EAAM,IAAI,MAAOhB,GAAQ,CACvB,IAAMiB,EAAS,MAAM,KAAK,eAAejB,CAAG,EAExCiB,GAAU,EAAEA,aAAkB,QAChC,KAAK,eAED,KAAK,OAAO,WAAW,KAAK,OAAO,UAAUA,CAAW,EAE5DN,EAAe,KAAKM,CAAW,GAE/BL,EAAc,KAAKK,CAAW,CAElC,CAAC,CACH,EAEI,KAAK,OAAO,YACd,KAAK,OAAO,WAAW,CACrB,UAAW,KAAK,aAChB,UAAW,KAAK,IAAIF,EAAgBD,EAAmB,CAAC,EACxD,OAAQ,KAAK,SACf,CAAC,EAGCA,EAAoBC,IACtB,MAAM,IAAI,QAASG,GAAY,CAAE,WAAWA,EAASL,CAAK,CAAG,CAAC,EAC9DA,EAAQ,KAAK,IACXA,EAAQ,KAAK,OAAO,qBACpB,KAAK,OAAO,qBAAuBA,CACrC,EAEJ,CAEA,OAAI,KAAK,OAAO,YAAc,CAAC,KAAK,aAClC,KAAK,OAAO,WAAW,CAAE,QAASF,EAAgB,OAAQC,CAAc,CAAC,EAGpE,CAAE,QAASD,EAAgB,OAAQC,CAAc,CAC1D,CACF,EAEO,SAASO,EAAkCd,EAA8B,CAC9E,OAAO,IAAIN,EAAcM,CAAQ,CACnC","names":["Limiter","req","controller","signal","error","ctrl","requests","concurrent","milliseconds","step","maxDelay","callback","successResults","failedResults","delay","currentBatchIndex","totalRequests","batch","result","resolve","promisesLimiter"]}