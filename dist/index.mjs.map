{"version":3,"sources":["../index.ts"],"sourcesContent":["export type AsyncFunction<T = any> = (signal: AbortSignal) => Promise<T>;\n\nexport interface SuccessHandler<T> {\n  (result: T): void;\n}\n\nexport interface ErrorHandler<E> {\n  (error: E): void;\n}\n\nexport interface ProgressHandler {\n  (progress: { completed: number; remaining: number; failed: number }): void;\n}\n\nexport interface CompletionHandler<T, E> {\n  (results: { success: T[]; failed: E[] }): void;\n}\n\nexport interface LimitConfig<T, E> {\n  maxConcurrent: number;\n  delayBetweenBatches: number;\n  progressiveDelayStep: number;\n  maxProgressiveDelay: number;\n  onSuccess?: SuccessHandler<T>;\n  onError?: ErrorHandler<E>;\n  onProgress?: ProgressHandler;\n  onComplete?: CompletionHandler<T, E>;\n}\n\nclass PromisesLimiter<T = any, E = any> {\n  #requests: AsyncFunction<T>[];\n  #config: LimitConfig<T, E>;\n  #successCount: number = 0;\n  #failCount: number = 0;\n  #isCancelled: boolean = false;\n  #abortControllers: AbortController[] = [];\n\n  async #executeRequest(req: AsyncFunction<T>): Promise<T | E> {\n    const controller = new AbortController();\n    this.#abortControllers.push(controller);\n    const { signal } = controller;\n\n    try {\n      return await req(signal);\n    } catch (error) {\n      this.#failCount++;\n\n      if (this.#config.onError) {\n        this.#config.onError(error as E)\n      };\n\n      return error as E;\n    } finally {\n      this.#abortControllers = this.#abortControllers.filter((ctrl) => ctrl !== controller);\n    }\n  }\n\n  constructor(requests: AsyncFunction<T>[], config?: Partial<LimitConfig<T, E>>) {\n    this.#requests = requests;\n    this.#config = {\n      maxConcurrent: 10,\n      delayBetweenBatches: 0,\n      progressiveDelayStep: 0,\n      maxProgressiveDelay: 0,\n      ...config,\n    };\n  }\n\n  cancel() {\n    this.#isCancelled = true;\n    this.#abortControllers.forEach((controller) => controller.abort());\n  }\n\n  async run(): Promise<{ success: T[]; failed: E[] }> {\n    const successResults: T[] = [];\n    const failedResults: E[] = [];\n    let delay = this.#config.delayBetweenBatches;\n    let currentBatchIndex = 0;\n\n    const totalRequests = this.#requests.length;\n\n    while (currentBatchIndex < totalRequests) {\n      if (this.#isCancelled) {\n        break;\n      }\n\n      const batch = this.#requests.slice(\n        currentBatchIndex,\n        currentBatchIndex + this.#config.maxConcurrent,\n      );\n      currentBatchIndex += this.#config.maxConcurrent;\n\n      await Promise.all(\n        batch.map(async (req) => {\n          const result = await this.#executeRequest(req);\n\n          if (result && !(result instanceof Error)) {\n            this.#successCount++;\n\n            if (this.#config.onSuccess) {\n              this.#config.onSuccess(result as T)\n            };\n\n            successResults.push(result as T);\n          } else {\n            failedResults.push(result as E);\n          }\n        }),\n      );\n\n      if (this.#config.onProgress) {\n        this.#config.onProgress({\n          completed: this.#successCount,\n          remaining: Math.max(totalRequests - currentBatchIndex, 0),\n          failed: this.#failCount,\n        });\n      }\n\n      if (currentBatchIndex < totalRequests) {\n        await new Promise((resolve) => { setTimeout(resolve, delay); });\n        delay = Math.min(\n          delay + this.#config.progressiveDelayStep,\n          this.#config.maxProgressiveDelay || delay,\n        );\n      }\n    }\n\n    if (this.#config.onComplete && !this.#isCancelled) {\n      this.#config.onComplete({ success: successResults, failed: failedResults });\n    }\n\n    return { success: successResults, failed: failedResults };\n  }\n}\n\nexport default PromisesLimiter;\n"],"mappings":"AA6BA,IAAMA,EAAN,KAAwC,CACtCC,GACAC,GACAC,GAAwB,EACxBC,GAAqB,EACrBC,GAAwB,GACxBC,GAAuC,CAAC,EAExC,KAAMC,GAAgBC,EAAuC,CAC3D,IAAMC,EAAa,IAAI,gBACvB,KAAKH,GAAkB,KAAKG,CAAU,EACtC,GAAM,CAAE,OAAAC,CAAO,EAAID,EAEnB,GAAI,CACF,OAAO,MAAMD,EAAIE,CAAM,CACzB,OAASC,EAAO,CACd,YAAKP,KAED,KAAKF,GAAQ,SACf,KAAKA,GAAQ,QAAQS,CAAU,EAG1BA,CACT,QAAE,CACA,KAAKL,GAAoB,KAAKA,GAAkB,OAAQM,GAASA,IAASH,CAAU,CACtF,CACF,CAEA,YAAYI,EAA8BC,EAAqC,CAC7E,KAAKb,GAAYY,EACjB,KAAKX,GAAU,CACb,cAAe,GACf,oBAAqB,EACrB,qBAAsB,EACtB,oBAAqB,EACrB,GAAGY,CACL,CACF,CAEA,QAAS,CACP,KAAKT,GAAe,GACpB,KAAKC,GAAkB,QAASG,GAAeA,EAAW,MAAM,CAAC,CACnE,CAEA,MAAM,KAA8C,CAClD,IAAMM,EAAsB,CAAC,EACvBC,EAAqB,CAAC,EACxBC,EAAQ,KAAKf,GAAQ,oBACrBgB,EAAoB,EAElBC,EAAgB,KAAKlB,GAAU,OAErC,KAAOiB,EAAoBC,GACrB,MAAKd,IAD+B,CAKxC,IAAMe,EAAQ,KAAKnB,GAAU,MAC3BiB,EACAA,EAAoB,KAAKhB,GAAQ,aACnC,EACAgB,GAAqB,KAAKhB,GAAQ,cAElC,MAAM,QAAQ,IACZkB,EAAM,IAAI,MAAOZ,GAAQ,CACvB,IAAMa,EAAS,MAAM,KAAKd,GAAgBC,CAAG,EAEzCa,GAAU,EAAEA,aAAkB,QAChC,KAAKlB,KAED,KAAKD,GAAQ,WACf,KAAKA,GAAQ,UAAUmB,CAAW,EAGpCN,EAAe,KAAKM,CAAW,GAE/BL,EAAc,KAAKK,CAAW,CAElC,CAAC,CACH,EAEI,KAAKnB,GAAQ,YACf,KAAKA,GAAQ,WAAW,CACtB,UAAW,KAAKC,GAChB,UAAW,KAAK,IAAIgB,EAAgBD,EAAmB,CAAC,EACxD,OAAQ,KAAKd,EACf,CAAC,EAGCc,EAAoBC,IACtB,MAAM,IAAI,QAASG,GAAY,CAAE,WAAWA,EAASL,CAAK,CAAG,CAAC,EAC9DA,EAAQ,KAAK,IACXA,EAAQ,KAAKf,GAAQ,qBACrB,KAAKA,GAAQ,qBAAuBe,CACtC,EAEJ,CAEA,OAAI,KAAKf,GAAQ,YAAc,CAAC,KAAKG,IACnC,KAAKH,GAAQ,WAAW,CAAE,QAASa,EAAgB,OAAQC,CAAc,CAAC,EAGrE,CAAE,QAASD,EAAgB,OAAQC,CAAc,CAC1D,CACF,EAEOO,EAAQvB","names":["PromisesLimiter","#requests","#config","#successCount","#failCount","#isCancelled","#abortControllers","#executeRequest","req","controller","signal","error","ctrl","requests","config","successResults","failedResults","delay","currentBatchIndex","totalRequests","batch","result","resolve","promises_limiter_default"]}