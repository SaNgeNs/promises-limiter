{"version":3,"sources":["../index.ts"],"sourcesContent":["export type AsyncFunction<T = any> = (signal: AbortSignal) => Promise<T>;\n\nexport interface SuccessHandler<T> {\n  (result: T): void;\n}\n\nexport interface ErrorHandler<E> {\n  (error: E): void;\n}\n\nexport interface ProgressHandler {\n  (progress: { completed: number; remaining: number; failed: number }): void;\n}\n\nexport interface CompletionHandler<T, E> {\n  (results: { success: T[]; failed: E[] }): void;\n}\n\nexport interface LimitConfig<T, E> {\n  maxConcurrent: number;\n  delayBetweenBatches: number;\n  progressiveDelayStep: number;\n  maxProgressiveDelay: number;\n  onSuccess?: SuccessHandler<T>;\n  onError?: ErrorHandler<E>;\n  onProgress?: ProgressHandler;\n  onComplete?: CompletionHandler<T, E>;\n}\n\nclass PromisesLimiter<T = any, E = any> {\n  #requests: AsyncFunction<T>[];\n  #config: LimitConfig<T, E>;\n  #isCancelled: boolean = false;\n  #abortControllers: AbortController[] = [];\n  #successResults: T[] = [];\n  #failedResults: E[] = [];\n  #currentDelay: number = 0;\n  #currentBatchIndex: number = 0;\n\n  async #executeRequest(req: AsyncFunction<T>): Promise<T | E> {\n    const controller = new AbortController();\n    this.#abortControllers.push(controller);\n    const { signal } = controller;\n\n    try {\n      return await req(signal);\n    } catch (error) {\n      if (this.#config.onError) {\n        this.#config.onError(error as E);\n      }\n\n      return error as E;\n    } finally {\n      this.#abortControllers = this.#abortControllers.filter((ctrl) => ctrl !== controller);\n    }\n  }\n\n  async #tick() {\n    const totalRequests = this.#requests.length;\n\n    if (!this.#isCancelled && this.#currentBatchIndex < totalRequests) {\n      const batch = this.#requests.slice(\n        this.#currentBatchIndex,\n        this.#currentBatchIndex + this.#config.maxConcurrent,\n      );\n      this.#currentBatchIndex += this.#config.maxConcurrent;\n\n      await Promise.all(\n        batch.map(async (req) => {\n          const result = await this.#executeRequest(req);\n\n          if (result && !(result instanceof Error)) {\n            if (this.#config.onSuccess) {\n              this.#config.onSuccess(result as T);\n            }\n\n            this.#successResults.push(result as T);\n          } else {\n            this.#failedResults.push(result as E);\n          }\n\n          if (this.#config.onProgress) {\n            this.#config.onProgress({\n              completed: this.#successResults.length,\n              remaining: Math.max(totalRequests - (this.#successResults.length + this.#failedResults.length), 0),\n              failed: this.#failedResults.length,\n            });\n          }\n        }),\n      );\n\n      if (this.#currentBatchIndex < totalRequests) {\n        await new Promise((resolve) => { setTimeout(resolve, this.#currentDelay); });\n\n        this.#currentDelay = Math.min(\n          this.#currentDelay + this.#config.progressiveDelayStep,\n          this.#config.maxProgressiveDelay || this.#currentDelay,\n        );\n\n        await this.#tick();\n      }\n    }\n  }\n\n  constructor(requests: AsyncFunction<T>[], config?: Partial<LimitConfig<T, E>>) {\n    this.#requests = requests;\n    this.#config = {\n      maxConcurrent: 10,\n      delayBetweenBatches: 0,\n      progressiveDelayStep: 0,\n      maxProgressiveDelay: 0,\n      ...config,\n    };\n  }\n\n  cancel() {\n    this.#isCancelled = true;\n    this.#abortControllers.forEach((controller) => controller.abort());\n  }\n\n  async run(): Promise<{ success: T[]; failed: E[] }> {\n    this.#successResults = [];\n    this.#failedResults = [];\n    this.#currentDelay = this.#config.delayBetweenBatches;\n    this.#currentBatchIndex = 0;\n\n    await this.#tick();\n\n    if (this.#config.onComplete && !this.#isCancelled) {\n      this.#config.onComplete({ success: this.#successResults, failed: this.#failedResults });\n    }\n\n    return { success: this.#successResults, failed: this.#failedResults };\n  }\n}\n\nexport default PromisesLimiter;\n"],"mappings":"AA6BA,IAAMA,EAAN,KAAwC,CACtCC,GACAC,GACAC,GAAwB,GACxBC,GAAuC,CAAC,EACxCC,GAAuB,CAAC,EACxBC,GAAsB,CAAC,EACvBC,GAAwB,EACxBC,GAA6B,EAE7B,KAAMC,GAAgBC,EAAuC,CAC3D,IAAMC,EAAa,IAAI,gBACvB,KAAKP,GAAkB,KAAKO,CAAU,EACtC,GAAM,CAAE,OAAAC,CAAO,EAAID,EAEnB,GAAI,CACF,OAAO,MAAMD,EAAIE,CAAM,CACzB,OAASC,EAAO,CACd,OAAI,KAAKX,GAAQ,SACf,KAAKA,GAAQ,QAAQW,CAAU,EAG1BA,CACT,QAAE,CACA,KAAKT,GAAoB,KAAKA,GAAkB,OAAQU,GAASA,IAASH,CAAU,CACtF,CACF,CAEA,KAAMI,IAAQ,CACZ,IAAMC,EAAgB,KAAKf,GAAU,OAErC,GAAI,CAAC,KAAKE,IAAgB,KAAKK,GAAqBQ,EAAe,CACjE,IAAMC,EAAQ,KAAKhB,GAAU,MAC3B,KAAKO,GACL,KAAKA,GAAqB,KAAKN,GAAQ,aACzC,EACA,KAAKM,IAAsB,KAAKN,GAAQ,cAExC,MAAM,QAAQ,IACZe,EAAM,IAAI,MAAOP,GAAQ,CACvB,IAAMQ,EAAS,MAAM,KAAKT,GAAgBC,CAAG,EAEzCQ,GAAU,EAAEA,aAAkB,QAC5B,KAAKhB,GAAQ,WACf,KAAKA,GAAQ,UAAUgB,CAAW,EAGpC,KAAKb,GAAgB,KAAKa,CAAW,GAErC,KAAKZ,GAAe,KAAKY,CAAW,EAGlC,KAAKhB,GAAQ,YACf,KAAKA,GAAQ,WAAW,CACtB,UAAW,KAAKG,GAAgB,OAChC,UAAW,KAAK,IAAIW,GAAiB,KAAKX,GAAgB,OAAS,KAAKC,GAAe,QAAS,CAAC,EACjG,OAAQ,KAAKA,GAAe,MAC9B,CAAC,CAEL,CAAC,CACH,EAEI,KAAKE,GAAqBQ,IAC5B,MAAM,IAAI,QAASG,GAAY,CAAE,WAAWA,EAAS,KAAKZ,EAAa,CAAG,CAAC,EAE3E,KAAKA,GAAgB,KAAK,IACxB,KAAKA,GAAgB,KAAKL,GAAQ,qBAClC,KAAKA,GAAQ,qBAAuB,KAAKK,EAC3C,EAEA,MAAM,KAAKQ,GAAM,EAErB,CACF,CAEA,YAAYK,EAA8BC,EAAqC,CAC7E,KAAKpB,GAAYmB,EACjB,KAAKlB,GAAU,CACb,cAAe,GACf,oBAAqB,EACrB,qBAAsB,EACtB,oBAAqB,EACrB,GAAGmB,CACL,CACF,CAEA,QAAS,CACP,KAAKlB,GAAe,GACpB,KAAKC,GAAkB,QAASO,GAAeA,EAAW,MAAM,CAAC,CACnE,CAEA,MAAM,KAA8C,CAClD,YAAKN,GAAkB,CAAC,EACxB,KAAKC,GAAiB,CAAC,EACvB,KAAKC,GAAgB,KAAKL,GAAQ,oBAClC,KAAKM,GAAqB,EAE1B,MAAM,KAAKO,GAAM,EAEb,KAAKb,GAAQ,YAAc,CAAC,KAAKC,IACnC,KAAKD,GAAQ,WAAW,CAAE,QAAS,KAAKG,GAAiB,OAAQ,KAAKC,EAAe,CAAC,EAGjF,CAAE,QAAS,KAAKD,GAAiB,OAAQ,KAAKC,EAAe,CACtE,CACF,EAEOgB,EAAQtB","names":["PromisesLimiter","#requests","#config","#isCancelled","#abortControllers","#successResults","#failedResults","#currentDelay","#currentBatchIndex","#executeRequest","req","controller","signal","error","ctrl","#tick","totalRequests","batch","result","resolve","requests","config","promises_limiter_default"]}