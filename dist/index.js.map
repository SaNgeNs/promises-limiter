{"version":3,"sources":["../index.ts"],"names":["Limiter","req","controller","signal","error","ctrl","requests","concurrent","milliseconds","step","maxDelay","callback","successResults","failedResults","delay","currentBatchIndex","totalRequests","batch","result","resolve","promisesLimiter"],"mappings":"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","file":"/home/lven/RQ-lib/promises-limiter/dist/index.js","sourcesContent":["export type AsyncFunction<T = any> = (signal: AbortSignal) => Promise<T>;\n\ninterface LimitConfig<T, E> {\n  maxConcurrent: number;\n  delayBetweenBatches: number;\n  progressiveDelayStep: number;\n  maxProgressiveDelay: number;\n  onSuccess?: (result: T) => void;\n  onError?: (error: E) => void;\n  onProgress?: (progress: { completed: number; remaining: number; failed: number }) => void;\n  onComplete?: (results: { success: T[]; failed: E[] }) => void;\n}\n\nclass Limiter<T = any, E = any> {\n  private requests: AsyncFunction<T>[];\n\n  private config: LimitConfig<T, E>;\n\n  private successCount: number = 0;\n\n  private failCount: number = 0;\n\n  private isCancelled: boolean = false;\n\n  private abortControllers: AbortController[] = [];\n\n  private async executeRequest(req: AsyncFunction<T>): Promise<T | E> {\n    const controller = new AbortController();\n    this.abortControllers.push(controller);\n    const { signal } = controller;\n\n    try {\n      return await req(signal);\n    } catch (error) {\n      this.failCount++;\n\n      if (this.config.onError) this.config.onError(error as E);\n\n      return error as E;\n    } finally {\n      this.abortControllers = this.abortControllers.filter((ctrl) => ctrl !== controller);\n    }\n  }\n\n  constructor(requests: AsyncFunction<T>[]) {\n    this.requests = requests;\n    this.config = {\n      maxConcurrent: 10,\n      delayBetweenBatches: 0,\n      progressiveDelayStep: 0,\n      maxProgressiveDelay: 0,\n    };\n  }\n\n  max(concurrent: number) {\n    this.config.maxConcurrent = concurrent;\n    return this;\n  }\n\n  delay(milliseconds: number) {\n    this.config.delayBetweenBatches = milliseconds;\n    return this;\n  }\n\n  progressiveDelay(step: number, maxDelay: number) {\n    this.config.progressiveDelayStep = step;\n    this.config.maxProgressiveDelay = maxDelay;\n    return this;\n  }\n\n  success(callback: (result: T) => void) {\n    this.config.onSuccess = callback;\n    return this;\n  }\n\n  error(callback: (error: E) => void) {\n    this.config.onError = callback;\n    return this;\n  }\n\n  progress(callback: (progress: { completed: number; remaining: number; failed: number }) => void) {\n    this.config.onProgress = callback;\n    return this;\n  }\n\n  complete(callback: (results: { success: T[]; failed: E[] }) => void) {\n    this.config.onComplete = callback;\n    return this;\n  }\n\n  cancel() {\n    this.isCancelled = true;\n    this.abortControllers.forEach((controller) => controller.abort());\n  }\n\n  async run(): Promise<{ success: T[]; failed: E[] }> {\n    const successResults: T[] = [];\n    const failedResults: E[] = [];\n    let delay = this.config.delayBetweenBatches;\n    let currentBatchIndex = 0;\n\n    const totalRequests = this.requests.length;\n\n    while (currentBatchIndex < totalRequests) {\n      if (this.isCancelled) {\n        break;\n      }\n\n      const batch = this.requests.slice(\n        currentBatchIndex,\n        currentBatchIndex + this.config.maxConcurrent,\n      );\n      currentBatchIndex += this.config.maxConcurrent;\n\n      await Promise.all(\n        batch.map(async (req) => {\n          const result = await this.executeRequest(req);\n\n          if (result && !(result instanceof Error)) {\n            this.successCount++;\n\n            if (this.config.onSuccess) this.config.onSuccess(result as T);\n\n            successResults.push(result as T);\n          } else {\n            failedResults.push(result as E);\n          }\n        }),\n      );\n\n      if (this.config.onProgress) {\n        this.config.onProgress({\n          completed: this.successCount,\n          remaining: Math.max(totalRequests - currentBatchIndex, 0),\n          failed: this.failCount,\n        });\n      }\n\n      if (currentBatchIndex < totalRequests) {\n        await new Promise((resolve) => { setTimeout(resolve, delay); });\n        delay = Math.min(\n          delay + this.config.progressiveDelayStep,\n          this.config.maxProgressiveDelay || delay,\n        );\n      }\n    }\n\n    if (this.config.onComplete && !this.isCancelled) {\n      this.config.onComplete({ success: successResults, failed: failedResults });\n    }\n\n    return { success: successResults, failed: failedResults };\n  }\n}\n\nexport function promisesLimiter<T = any, E = any>(requests: AsyncFunction<T>[]) {\n  return new Limiter<T, E>(requests);\n}\n"]}