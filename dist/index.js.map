{"version":3,"sources":["../index.ts"],"names":["PromisesLimiter","#requests","#config","#isCancelled","#abortControllers","#successResults","#failedResults","#currentDelay","#currentBatchIndex","#executeRequest","req","controller","signal","error","ctrl","#tick","totalRequests","batch","result","resolve","requests","config","promises_limiter_default"],"mappings":"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","file":"/home/lven/RQ-lib/promises-limiter/dist/index.js","sourcesContent":["export type AsyncFunction<T = any> = (signal: AbortSignal) => Promise<T>;\n\nexport interface SuccessHandler<T> {\n  (result: T): void;\n}\n\nexport interface ErrorHandler<E> {\n  (error: E): void;\n}\n\nexport interface ProgressHandler {\n  (progress: { completed: number; remaining: number; failed: number }): void;\n}\n\nexport interface CompletionHandler<T, E> {\n  (results: { success: T[]; failed: E[] }): void;\n}\n\nexport interface LimitConfig<T, E> {\n  maxConcurrent: number;\n  delayBetweenBatches: number;\n  progressiveDelayStep: number;\n  maxProgressiveDelay: number;\n  onSuccess?: SuccessHandler<T>;\n  onError?: ErrorHandler<E>;\n  onProgress?: ProgressHandler;\n  onComplete?: CompletionHandler<T, E>;\n}\n\nclass PromisesLimiter<T = any, E = any> {\n  #requests: AsyncFunction<T>[];\n  #config: LimitConfig<T, E>;\n  #isCancelled: boolean = false;\n  #abortControllers: AbortController[] = [];\n  #successResults: T[] = [];\n  #failedResults: E[] = [];\n  #currentDelay: number = 0;\n  #currentBatchIndex: number = 0;\n\n  async #executeRequest(req: AsyncFunction<T>): Promise<T | E> {\n    const controller = new AbortController();\n    this.#abortControllers.push(controller);\n    const { signal } = controller;\n\n    try {\n      return await req(signal);\n    } catch (error) {\n      if (this.#config.onError) {\n        this.#config.onError(error as E);\n      }\n\n      return error as E;\n    } finally {\n      this.#abortControllers = this.#abortControllers.filter((ctrl) => ctrl !== controller);\n    }\n  }\n\n  async #tick() {\n    const totalRequests = this.#requests.length;\n\n    if (!this.#isCancelled && this.#currentBatchIndex < totalRequests) {\n      const batch = this.#requests.slice(\n        this.#currentBatchIndex,\n        this.#currentBatchIndex + this.#config.maxConcurrent,\n      );\n      this.#currentBatchIndex += this.#config.maxConcurrent;\n\n      await Promise.all(\n        batch.map(async (req) => {\n          const result = await this.#executeRequest(req);\n\n          if (result && !(result instanceof Error)) {\n            if (this.#config.onSuccess) {\n              this.#config.onSuccess(result as T);\n            }\n\n            this.#successResults.push(result as T);\n          } else {\n            this.#failedResults.push(result as E);\n          }\n\n          if (this.#config.onProgress) {\n            this.#config.onProgress({\n              completed: this.#successResults.length,\n              remaining: Math.max(totalRequests - (this.#successResults.length + this.#failedResults.length), 0),\n              failed: this.#failedResults.length,\n            });\n          }\n        }),\n      );\n\n      if (this.#currentBatchIndex < totalRequests) {\n        await new Promise((resolve) => { setTimeout(resolve, this.#currentDelay); });\n\n        this.#currentDelay = Math.min(\n          this.#currentDelay + this.#config.progressiveDelayStep,\n          this.#config.maxProgressiveDelay || this.#currentDelay,\n        );\n\n        await this.#tick();\n      }\n    }\n  }\n\n  constructor(requests: AsyncFunction<T>[], config?: Partial<LimitConfig<T, E>>) {\n    this.#requests = requests;\n    this.#config = {\n      maxConcurrent: 10,\n      delayBetweenBatches: 0,\n      progressiveDelayStep: 0,\n      maxProgressiveDelay: 0,\n      ...config,\n    };\n  }\n\n  cancel() {\n    this.#isCancelled = true;\n    this.#abortControllers.forEach((controller) => controller.abort());\n  }\n\n  async run(): Promise<{ success: T[]; failed: E[] }> {\n    this.#successResults = [];\n    this.#failedResults = [];\n    this.#currentDelay = this.#config.delayBetweenBatches;\n    this.#currentBatchIndex = 0;\n\n    await this.#tick();\n\n    if (this.#config.onComplete && !this.#isCancelled) {\n      this.#config.onComplete({ success: this.#successResults, failed: this.#failedResults });\n    }\n\n    return { success: this.#successResults, failed: this.#failedResults };\n  }\n}\n\nexport default PromisesLimiter;\n"]}