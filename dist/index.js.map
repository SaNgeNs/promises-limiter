{"version":3,"sources":["../index.ts"],"names":["Limiter","req","controller","signal","error","ctrl","requests","concurrent","milliseconds","step","maxDelay","callback","successResults","failedResults","delay","currentBatchIndex","totalRequests","batch","result","resolve","PromisesLimiter"],"mappings":"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","file":"/home/lven/RQ-lib/promises-limiter/dist/index.js","sourcesContent":["type AsyncFunction<T = any> = (signal: AbortSignal) => Promise<T>;\n\ninterface LimitConfig {\n  maxConcurrent: number;\n  delayBetweenBatches: number;\n  progressiveDelayStep: number;\n  maxProgressiveDelay: number;\n  onSuccess?: (result: any) => void;\n  onError?: (error: any) => void;\n  onProgress?: (progress: { completed: number; remaining: number; failed: number }) => void;\n  onComplete?: (results: { success: any[]; failed: any[] }) => void;\n}\n\nclass Limiter {\n  private requests: AsyncFunction[];\n\n  private config: LimitConfig;\n\n  private successCount: number = 0;\n\n  private failCount: number = 0;\n\n  private isCancelled: boolean = false;\n\n  private abortControllers: AbortController[] = [];\n\n  private async executeRequest(req: AsyncFunction): Promise<any> {\n    const controller = new AbortController();\n    this.abortControllers.push(controller);\n    const { signal } = controller;\n\n    try {\n      return await req(signal);\n    } catch (error) {\n      this.failCount++;\n\n      if (this.config.onError) this.config.onError(error);\n\n      return error;\n    } finally {\n      this.abortControllers = this.abortControllers.filter((ctrl) => ctrl !== controller);\n    }\n  }\n\n  constructor(requests: AsyncFunction[]) {\n    this.requests = requests;\n    this.config = {\n      maxConcurrent: 10,\n      delayBetweenBatches: 0,\n      progressiveDelayStep: 0,\n      maxProgressiveDelay: 0,\n    };\n  }\n\n  max(concurrent: number) {\n    this.config.maxConcurrent = concurrent;\n    return this;\n  }\n\n  delay(milliseconds: number) {\n    this.config.delayBetweenBatches = milliseconds;\n    return this;\n  }\n\n  progressiveDelay(step: number, maxDelay: number) {\n    this.config.progressiveDelayStep = step;\n    this.config.maxProgressiveDelay = maxDelay;\n    return this;\n  }\n\n  success(callback: (result: any) => void) {\n    this.config.onSuccess = callback;\n    return this;\n  }\n\n  error(callback: (error: any) => void) {\n    this.config.onError = callback;\n    return this;\n  }\n\n  progress(callback: (progress: { completed: number; remaining: number; failed: number }) => void) {\n    this.config.onProgress = callback;\n    return this;\n  }\n\n  complete(callback: (results: { success: any[]; failed: any[] }) => void) {\n    this.config.onComplete = callback;\n    return this;\n  }\n\n  cancel() {\n    this.isCancelled = true;\n    this.abortControllers.forEach((controller) => controller.abort());\n  }\n\n  async run(): Promise<{ success: any[]; failed: any[] }> {\n    const successResults: any[] = [];\n    const failedResults: any[] = [];\n    let delay = this.config.delayBetweenBatches;\n    let currentBatchIndex = 0;\n\n    const totalRequests = this.requests.length;\n\n    while (currentBatchIndex < totalRequests) {\n      if (this.isCancelled) {\n        break;\n      }\n\n      const batch = this.requests.slice(\n        currentBatchIndex,\n        currentBatchIndex + this.config.maxConcurrent,\n      );\n      currentBatchIndex += this.config.maxConcurrent;\n\n      await Promise.all(\n        batch.map(async (req) => {\n          const result = await this.executeRequest(req);\n\n          if (result && !(result instanceof Error)) {\n            this.successCount++;\n\n            if (this.config.onSuccess) this.config.onSuccess(result);\n\n            successResults.push(result);\n          } else {\n            failedResults.push(result);\n          }\n        }),\n      );\n\n      if (this.config.onProgress) {\n        this.config.onProgress({\n          completed: this.successCount,\n          remaining: totalRequests - currentBatchIndex,\n          failed: this.failCount,\n        });\n      }\n\n      if (currentBatchIndex < totalRequests) {\n        await new Promise((resolve) => { setTimeout(resolve, delay); });\n        delay = Math.min(delay + this.config.progressiveDelayStep, this.config.maxProgressiveDelay);\n      }\n    }\n\n    if (this.config.onComplete && !this.isCancelled) {\n      this.config.onComplete({ success: successResults, failed: failedResults });\n    }\n\n    return { success: successResults, failed: failedResults };\n  }\n}\n\nexport function PromisesLimiter(requests: AsyncFunction[]) {\n  return new Limiter(requests);\n}\n"]}