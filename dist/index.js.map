{"version":3,"sources":["../index.ts"],"names":["PromisesLimiter","#requests","#config","#successCount","#failCount","#isCancelled","#abortControllers","#executeRequest","req","controller","signal","error","ctrl","requests","config","successResults","failedResults","delay","currentBatchIndex","totalRequests","batch","result","resolve","promises_limiter_default"],"mappings":"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","file":"/home/lven/RQ-lib/promises-limiter/dist/index.js","sourcesContent":["export type AsyncFunction<T = any> = (signal: AbortSignal) => Promise<T>;\n\nexport interface SuccessHandler<T> {\n  (result: T): void;\n}\n\nexport interface ErrorHandler<E> {\n  (error: E): void;\n}\n\nexport interface ProgressHandler {\n  (progress: { completed: number; remaining: number; failed: number }): void;\n}\n\nexport interface CompletionHandler<T, E> {\n  (results: { success: T[]; failed: E[] }): void;\n}\n\nexport interface LimitConfig<T, E> {\n  maxConcurrent: number;\n  delayBetweenBatches: number;\n  progressiveDelayStep: number;\n  maxProgressiveDelay: number;\n  onSuccess?: SuccessHandler<T>;\n  onError?: ErrorHandler<E>;\n  onProgress?: ProgressHandler;\n  onComplete?: CompletionHandler<T, E>;\n}\n\nclass PromisesLimiter<T = any, E = any> {\n  #requests: AsyncFunction<T>[];\n  #config: LimitConfig<T, E>;\n  #successCount: number = 0;\n  #failCount: number = 0;\n  #isCancelled: boolean = false;\n  #abortControllers: AbortController[] = [];\n\n  async #executeRequest(req: AsyncFunction<T>): Promise<T | E> {\n    const controller = new AbortController();\n    this.#abortControllers.push(controller);\n    const { signal } = controller;\n\n    try {\n      return await req(signal);\n    } catch (error) {\n      this.#failCount++;\n\n      if (this.#config.onError) {\n        this.#config.onError(error as E);\n      }\n\n      return error as E;\n    } finally {\n      this.#abortControllers = this.#abortControllers.filter((ctrl) => ctrl !== controller);\n    }\n  }\n\n  constructor(requests: AsyncFunction<T>[], config?: Partial<LimitConfig<T, E>>) {\n    this.#requests = requests;\n    this.#config = {\n      maxConcurrent: 10,\n      delayBetweenBatches: 0,\n      progressiveDelayStep: 0,\n      maxProgressiveDelay: 0,\n      ...config,\n    };\n  }\n\n  cancel() {\n    this.#isCancelled = true;\n    this.#abortControllers.forEach((controller) => controller.abort());\n  }\n\n  async run(): Promise<{ success: T[]; failed: E[] }> {\n    this.#successCount = 0;\n    this.#failCount = 0;\n\n    const successResults: T[] = [];\n    const failedResults: E[] = [];\n    let delay = this.#config.delayBetweenBatches;\n    let currentBatchIndex = 0;\n\n    const totalRequests = this.#requests.length;\n\n    while (currentBatchIndex < totalRequests) {\n      if (this.#isCancelled) {\n        break;\n      }\n\n      const batch = this.#requests.slice(\n        currentBatchIndex,\n        currentBatchIndex + this.#config.maxConcurrent,\n      );\n      currentBatchIndex += this.#config.maxConcurrent;\n\n      await Promise.all(\n        batch.map(async (req) => {\n          const result = await this.#executeRequest(req);\n\n          if (result && !(result instanceof Error)) {\n            this.#successCount++;\n\n            if (this.#config.onSuccess) {\n              this.#config.onSuccess(result as T);\n            }\n\n            successResults.push(result as T);\n          } else {\n            failedResults.push(result as E);\n          }\n\n          if (this.#config.onProgress) {\n            this.#config.onProgress({\n              completed: this.#successCount,\n              remaining: Math.max(totalRequests - (this.#successCount + this.#failCount), 0),\n              failed: this.#failCount,\n            });\n          }\n        }),\n      );\n\n      if (currentBatchIndex < totalRequests) {\n        await new Promise((resolve) => { setTimeout(resolve, delay); });\n        delay = Math.min(\n          delay + this.#config.progressiveDelayStep,\n          this.#config.maxProgressiveDelay || delay,\n        );\n      }\n    }\n\n    if (this.#config.onComplete && !this.#isCancelled) {\n      this.#config.onComplete({ success: successResults, failed: failedResults });\n    }\n\n    return { success: successResults, failed: failedResults };\n  }\n}\n\nexport default PromisesLimiter;\n"]}