var c=class{requests;config;successCount=0;failCount=0;isCancelled=!1;abortControllers=[];async executeRequest(e){let r=new AbortController;this.abortControllers.push(r);let{signal:t}=r;try{return await e(t)}catch(s){return this.failCount++,this.config.onError&&this.config.onError(s),s}finally{this.abortControllers=this.abortControllers.filter(s=>s!==r)}}constructor(e){this.requests=e,this.config={maxConcurrent:10,delayBetweenBatches:0,progressiveDelayStep:0,maxProgressiveDelay:0}}max(e){return this.config.maxConcurrent=e,this}delay(e){return this.config.delayBetweenBatches=e,this}progressiveDelay(e,r){return this.config.progressiveDelayStep=e,this.config.maxProgressiveDelay=r,this}success(e){return this.config.onSuccess=e,this}error(e){return this.config.onError=e,this}progress(e){return this.config.onProgress=e,this}complete(e){return this.config.onComplete=e,this}cancel(){this.isCancelled=!0,this.abortControllers.forEach(e=>e.abort())}async run(){let e=[],r=[],t=this.config.delayBetweenBatches,s=0,i=this.requests.length;for(;s<i&&!this.isCancelled;){let l=this.requests.slice(s,s+this.config.maxConcurrent);s+=this.config.maxConcurrent,await Promise.all(l.map(async o=>{let n=await this.executeRequest(o);n&&!(n instanceof Error)?(this.successCount++,this.config.onSuccess&&this.config.onSuccess(n),e.push(n)):r.push(n)})),this.config.onProgress&&this.config.onProgress({completed:this.successCount,remaining:i-s,failed:this.failCount}),s<i&&(await new Promise(o=>{setTimeout(o,t)}),t=Math.min(t+this.config.progressiveDelayStep,this.config.maxProgressiveDelay))}return this.config.onComplete&&!this.isCancelled&&this.config.onComplete({success:e,failed:r}),{success:e,failed:r}}};function u(a){return new c(a)}export{u as PromisesLimiter};
//# sourceMappingURL=index.mjs.map