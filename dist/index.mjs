var a=class{#r;#e;#n=0;#o=0;#t=!1;#s=[];async#i(s){let r=new AbortController;this.#s.push(r);let{signal:t}=r;try{return await s(t)}catch(e){return this.#o++,this.#e.onError&&this.#e.onError(e),e}finally{this.#s=this.#s.filter(e=>e!==r)}}constructor(s,r){this.#r=s,this.#e={maxConcurrent:10,delayBetweenBatches:0,progressiveDelayStep:0,maxProgressiveDelay:0,...r}}cancel(){this.#t=!0,this.#s.forEach(s=>s.abort())}async run(){let s=[],r=[],t=this.#e.delayBetweenBatches,e=0,o=this.#r.length;for(;e<o&&!this.#t;){let c=this.#r.slice(e,e+this.#e.maxConcurrent);e+=this.#e.maxConcurrent,await Promise.all(c.map(async i=>{let n=await this.#i(i);n&&!(n instanceof Error)?(this.#n++,this.#e.onSuccess&&this.#e.onSuccess(n),s.push(n)):r.push(n)})),this.#e.onProgress&&this.#e.onProgress({completed:this.#n,remaining:Math.max(o-e,0),failed:this.#o}),e<o&&(await new Promise(i=>{setTimeout(i,t)}),t=Math.min(t+this.#e.progressiveDelayStep,this.#e.maxProgressiveDelay||t))}return this.#e.onComplete&&!this.#t&&this.#e.onComplete({success:s,failed:r}),{success:s,failed:r}}},u=a;export{u as default};
//# sourceMappingURL=index.mjs.map